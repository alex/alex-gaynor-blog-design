<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Alex Gaynor</title>
        <link rel="stylesheet" href="css/app.css">
    </head>
    <body>
        <header class="site-header">
            <h1>Hi, I&rsquo;m Alex</h1>
            <nav>
                <a href="index.html" title="Home"><span class="home">Home</span></a>
                <a href="#" title="Twitter"><span class="twitter">Twitter</span></a>
                <a href="#" title=""><span class="link">link</span></a>
                <a href="#" title=""><span class="link">link</span></a>
                <a href="#" title=""><span class="link">link</span></a>
                <a href="#" title=""><span class="link">link</span></a>
            </nav>
        </header>

        <main>
            <article>
                <header>
                    <h1>Disambiguating BSON and msgpack</h1>
                    <div class="meta">
                        <time class="updated" datetime="2013-02-16" pubdate="">
                            <a href="/2013/">2013-02-16</a>
                        </time>
                        <span class="author vcard">by <span class="fn">alex_gaynor</span></span>
                    </div>
                </header>
                <p>I had a fairly fun project at work recently, so I thought I'd write about it.  We currently store <a class="reference external" href="http://bsonspec.org/">BSON</a> blobs of data in many places. This is unfortunate, because BSON is bloated and slow (an array is internally stored as a dictionary mapping the strings <tt class="docutils literal">"0"</tt>, <tt class="docutils literal">"1"</tt>, <tt class="docutils literal">"2"</tt>, etc. to values). So we wanted to migrate to <a class="reference external" href="http://msgpack.org/">msgpack</a>, which I've measured as requiring 46% of the space of BSON, and being significantly faster to deserialize (we aren't concerned with serialization speed, though I'm relatively confident that's faster as well).</p>
                <p>The one trick we wanted to pull was to do the migration in place, that is gradually rewrite all the columns' data from BSON to msgpack. This is only possible if the data can be interpreted as one or the other unambiguously. So I was tasked if finding out if this was possible.</p>
                <p>The first thing that's important to know about BSON is that the first 4-bytes are the length of the entire document (in bytes) as a signed integer, little endian. msgpack has no specific prefix, the first bytes are merely the typecode for whatever the element is. At <a class="reference external" href="http://www.rdio.com/">Rdio</a>, we know something about our data though, because BSON requires all top-level elements to be dictionaries, and we're just re-serializing the same data, we know that all of these msgpacks will have dictionaries as the top level object.</p>
                <p>Because a BSON blob starts with its size, in bytes, we're going to try to find the smallest possible 4-byte starting sequence (interpreted as an integer) one of our payloads could have, in order to determine what the smallest possible ambiguity is.</p>
                <p>So the first case is the empty dictionary, in msgpack this is serialized as:</p>
                <div class="highlight">
                    <pre><span class="gp">&gt;&gt;&gt; </span><span class="n">msgpack</span><span class="o">.</span><span class="n">packb</span><span class="p">({})</span>
<span class="go">'\x80'</span>
                </pre></div>
                <p>That's less than 4 bytes, and all BSONs are at least 4 bytes, so that can't be ambiguous. Now let's look at a dictionary with some content. Another thing we know about our payloads is that all the keys in the dictionaries are strings, and that the keys are alphanumeric or underscores. Looking at the <a class="reference external" href="http://wiki.msgpack.org/display/MSGPACK/Format+specification">msgpack spec</a>, the smallest key (interpreted as its serialized integer value) that could exist is <tt class="docutils literal">"0"</tt>, since <tt class="docutils literal">"0"</tt> has the lowest ASCII value of any letter, number, or underscore. Further, from the <a class="reference external" href="http://wiki.msgpack.org/display/MSGPACK/Format+specification">msgpack spec</a> we know that the number <tt class="docutils literal">0</tt> serializes as a single byte, so that will be the key's value.  Let's see where this gets us:</p>
                <div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">msgpack</span><span class="o">.</span><span class="n">packb</span><span class="p">({</span><span class="s">"0"</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
                <span class="go">'\x81\xa10\x00'</span>
                </pre></div>
                <p>A 4 byte result, perfect, this is the smallest prefix we can generate, let's see how many bytes this would be:</p>
                <div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'&lt;l'</span><span class="p">,</span> <span class="s">'</span><span class="se">\x81\xa1</span><span class="s">0</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>
                <span class="go">(3187073,)</span>
                </pre></div>
                <p>3187073 bytes, or a little over 3 MB. To be honest I'm not sure we have a key that starts with a number, let's try with the key <tt class="docutils literal">"a"</tt>:</p>
                <div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">msgpack</span><span class="o">.</span><span class="n">packb</span><span class="p">({</span><span class="s">"a"</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
                <span class="go">'\x81\xa1a\x00'</span>
                <span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'&lt;l'</span><span class="p">,</span> <span class="s">'</span><span class="se">\x81\xa1</span><span class="s">a</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>
                <span class="go">(6398337,)</span>
                </pre></div>
                <p>A little over 6 MB. Since I know that none of the payloads we store are anywhere close to this large, we can safely store either serialization format, and be able to interpret the result unambiguously as one or the other.</p> <p>So our final detection code looks like:</p>
                <div class="highlight"><pre><span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'&lt;l'</span><span class="p">,</span> <span class="n">s</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">BSON</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">unpackb</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                </pre></div>
                <p>If this sounds like a fun kind of the thing to do, you should <a class="reference external" href="http://www.rdio.com/careers/">apply to come work with me at Rdio</a>.</p>

                <section class="comments">
                    <p>Comments are never going to happen. Stop trying to make comments happen.</p>
                </section>
            </article>
        </main>

        <footer class="site-footer">
            <p>&copy; Alex Gaynor. Blah blah blah</p>
        </footer>
    </body>
</html>
